:mod:`pymor.models.iosys`
=========================

.. py:module:: pymor.models.iosys


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pymor.models.iosys.LTIModel
   pymor.models.iosys.SecondOrderModel
   pymor.models.iosys.LinearDelayModel
   pymor.models.iosys.LinearStochasticModel
   pymor.models.iosys.BilinearModel



Functions
~~~~~~~~~

.. autoapisummary::
  :nosignatures:

   pymor.models.iosys.sparse_min_size
   pymor.models.iosys._lti_to_poles_b_c
   pymor.models.iosys._poles_b_c_to_lti



.. py:function:: sparse_min_size(value=1000)

   Return minimal sparse problem size for which to warn about converting to dense.


.. py:class:: LTIModel(A, B, C, D=None, E=None, sampling_time=0, solver_options=None, error_estimator=None, visualizer=None, name=None)

   Bases: :py:obj:`pymor.models.interface.Model`

   Class for linear time-invariant systems.

   This class describes input-state-output systems given by

   .. math::
       E(\mu) \dot{x}(t, \mu) & = A(\mu) x(t, \mu) + B(\mu) u(t), \\
                    y(t, \mu) & = C(\mu) x(t, \mu) + D(\mu) u(t),

   if continuous-time, or

   .. math::
       E(\mu) x(k + 1, \mu) & = A(\mu) x(k, \mu) + B(\mu) u(k), \\
              y(k, \mu)     & = C(\mu) x(k, \mu) + D(\mu) u(k),

   if discrete-time, where :math:`A`, :math:`B`, :math:`C`, :math:`D`, and :math:`E` are linear
   operators.

   All methods related to the transfer function
   (e.g., frequency response calculation and Bode plots)
   are attached to the `transfer_function` attribute.

   .. admonition:: Parameters

       A
           The |Operator| A.
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       sampling_time
           `0` if the system is continuous-time, otherwise a positive number that denotes the
           sampling time (in seconds).
       solver_options
           The solver options to use to solve the Lyapunov equations.
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a
           `visualize(U, model, ...)` method. If `visualizer` is not `None`, a
           `visualize(U, *args, **kwargs)` method is added to the model which forwards its arguments to
           the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system.

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.

   .. attribute:: transfer_function

      The transfer function.
      

   .. py:method:: __str__(self)

      Return str(self).


   .. py:method:: from_matrices(cls, A, B, C, D=None, E=None, sampling_time=0, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices.

      .. admonition:: Parameters

          A
              The |NumPy array| or |SciPy spmatrix| A.
          B
              The |NumPy array| or |SciPy spmatrix| B.
          C
              The |NumPy array| or |SciPy spmatrix| C.
          D
              The |NumPy array| or |SciPy spmatrix| D or `None` (then D is assumed to be zero).
          E
              The |NumPy array| or |SciPy spmatrix| E or `None` (then E is assumed to be identity).
          sampling_time
              `0` if the system is continuous-time, otherwise a positive number that denotes the
              sampling time (in seconds).
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              

   .. py:method:: to_matrices(self)

      Return operators as matrices.

      .. admonition:: Returns

          A
              The |NumPy array| or |SciPy spmatrix| A.
          B
              The |NumPy array| or |SciPy spmatrix| B.
          C
              The |NumPy array| or |SciPy spmatrix| C.
          D
              The |NumPy array| or |SciPy spmatrix| D or `None` (if D is a `ZeroOperator`).
          E
              The |NumPy array| or |SciPy spmatrix| E or `None` (if E is an `IdentityOperator`).
              

   .. py:method:: from_files(cls, A_file, B_file, C_file, D_file=None, E_file=None, sampling_time=0, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in separate files.

      .. admonition:: Parameters

          A_file
              The name of the file (with extension) containing A.
          B_file
              The name of the file (with extension) containing B.
          C_file
              The name of the file (with extension) containing C.
          D_file
              `None` or the name of the file (with extension) containing D.
          E_file
              `None` or the name of the file (with extension) containing E.
          sampling_time
              `0` if the system is continuous-time, otherwise a positive number that denotes the
              sampling time (in seconds).
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              

   .. py:method:: to_files(self, A_file, B_file, C_file, D_file=None, E_file=None)

      Write operators to files as matrices.

      .. admonition:: Parameters

          A_file
              The name of the file (with extension) containing A.
          B_file
              The name of the file (with extension) containing B.
          C_file
              The name of the file (with extension) containing C.
          D_file
              The name of the file (with extension) containing D or `None` if D is a `ZeroOperator`.
          E_file
              The name of the file (with extension) containing E or `None` if E is an
              `IdentityOperator`.
              

   .. py:method:: from_mat_file(cls, file_name, sampling_time=0, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in a .mat file.

      .. admonition:: Parameters

          file_name
              The name of the .mat file (extension .mat does not need to be included) containing A, B,
              C, and optionally D and E.
          sampling_time
              `0` if the system is continuous-time, otherwise a positive number that denotes the
              sampling time (in seconds).
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              

   .. py:method:: to_mat_file(self, file_name)

      Save operators as matrices to .mat file.

      .. admonition:: Parameters

          file_name
              The name of the .mat file (extension .mat does not need to be included).
              

   .. py:method:: from_abcde_files(cls, files_basename, sampling_time=0, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in .[ABCDE] files.

      .. admonition:: Parameters

          files_basename
              The basename of files containing A, B, C, and optionally D and E.
          sampling_time
              `0` if the system is continuous-time, otherwise a positive number that denotes the
              sampling time (in seconds).
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The |LTIModel| with operators A, B, C, D, and E.
              

   .. py:method:: to_abcde_files(self, files_basename)

      Save operators as matrices to .[ABCDE] files in Matrix Market format.

      .. admonition:: Parameters

          files_basename
              The basename of files containing the operators.
              

   .. py:method:: __add__(self, other)

      Add an |LTIModel|.


   .. py:method:: __sub__(self, other)

      Subtract an |LTIModel|.


   .. py:method:: __neg__(self)

      Negate the |LTIModel|.


   .. py:method:: __mul__(self, other)

      Postmultiply by an |LTIModel|.


   .. py:method:: poles(self, mu=None)

      Compute system poles.

      .. note::
          Assumes the systems is small enough to use a dense eigenvalue solver.

      .. admonition:: Parameters

          mu
              |Parameter values| for which to compute the systems poles.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of system poles.
              

   .. py:method:: gramian(self, typ, mu=None)

      Compute a Gramian.

      .. admonition:: Parameters

          typ
              The type of the Gramian:
              
              - `'c_lrcf'`: low-rank Cholesky factor of the controllability Gramian,
              - `'o_lrcf'`: low-rank Cholesky factor of the observability Gramian,
              - `'c_dense'`: dense controllability Gramian,
              - `'o_dense'`: dense observability Gramian.
              
              .. note::
                  For `'*_lrcf'` types, the method assumes the system is asymptotically stable.
                  For `'*_dense'` types, the method assumes that the underlying Lyapunov equation
                  has a unique solution, i.e. no pair of system poles adds to zero in the
                  continuous-time case and no pair of system poles multiplies to one in the
                  discrete-time case.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          If typ is `'c_lrcf'` or `'o_lrcf'`, then the Gramian factor as a |VectorArray| from
          `self.A.source`.
          If typ is `'c_dense'` or `'o_dense'`, then the Gramian as a |NumPy array|.
              

   .. py:method:: _hsv_U_V(self, mu=None)

      Compute Hankel singular values and vectors.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          hsv
              One-dimensional |NumPy array| of singular values.
          Uh
              |NumPy array| of left singular vectors.
          Vh
              |NumPy array| of right singular vectors.
              

   .. py:method:: hsv(self, mu=None)

      Hankel singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          sv
              One-dimensional |NumPy array| of singular values.
              

   .. py:method:: h2_norm(self, mu=None)

      Compute the H2-norm of the |LTIModel|.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              H_2-norm.
              

   .. py:method:: hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False)

      Compute the H_infinity-norm of the |LTIModel|.

      .. note::
          Assumes the system is asymptotically stable. Under this is assumption
          the H_infinity-norm is equal to the L_infinity-norm. Accordingly, this
          method calls :meth:`~pymor.models.iosys.LTIModel.linf_norm`.

      .. admonition:: Parameters

          mu
              |Parameter values|.
          return_fpeak
              Whether to return the frequency at which the maximum is achieved.
          ab13dd_equilibrate
              Whether `slycot.ab13dd` should use equilibration.
              
      .. admonition:: Returns

          norm
              H_infinity-norm.
          fpeak
              Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
              

   .. py:method:: hankel_norm(self, mu=None)

      Compute the Hankel-norm of the |LTIModel|.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              Hankel-norm.
              

   .. py:method:: l2_norm(self, ast_pole_data=None, mu=None)

      Compute the L2-norm of the |LTIModel|.

      The L2-norm of an |LTIModel| is defined via the integral

      .. math::
          \lVert H \rVert_{\mathcal{L}_2}
          =
          \left(
            \frac{1}{2 \pi}
            \int_{-\infty}^{\infty}
            \lVert H(\boldsymbol{\imath} \omega) \rVert_{\operatorname{F}}^2
            \operatorname{d}\!\omega
          \right)^{\frac{1}{2}}.

      .. admonition:: Parameters

          ast_pole_data
              Can be:
              
              - dictionary of parameters for :func:`~pymor.algorithms.eigs.eigs`,
              - list of anti-stable eigenvalues (scalars),
              - tuple `(lev, ew, rev)` where `ew` contains the anti-stable eigenvalues
                and `lev` and `rev` are |VectorArrays| representing the eigenvectors.
              - `None` if anti-stable eigenvalues should be computed via dense methods.
          mu
              |Parameter|.
              
      .. admonition:: Returns

          norm
              L_2-norm.
              

   .. py:method:: linf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False)

      Compute the L_infinity-norm of the |LTIModel|.

      The L-infinity norm of an |LTIModel| is defined via

      .. math::

          \lVert H \rVert_{\mathcal{L}_\infty}
          = \sup_{\omega \in \mathbb{R}}
          \lVert H(\boldsymbol{\imath} \omega) \rVert_2.

      .. admonition:: Parameters

          mu
              |Parameter|.
          return_fpeak
              Whether to return the frequency at which the maximum is achieved.
          ab13dd_equilibrate
              Whether `slycot.ab13dd` should use equilibration.
              
      .. admonition:: Returns

          norm
              L_infinity-norm.
          fpeak
              Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
              

   .. py:method:: get_ast_spectrum(self, ast_pole_data=None, mu=None)

      Compute anti-stable subset of the poles of the |LTIModel|.

      .. admonition:: Parameters

          ast_pole_data
              Can be:
              
              - dictionary of parameters for :func:`~pymor.algorithms.eigs.eigs`,
              - list of anti-stable eigenvalues (scalars),
              - tuple `(lev, ew, rev)` where `ew` contains the sorted anti-stable eigenvalues
                and `lev` and `rev` are |VectorArrays| representing the eigenvectors.
              - `None` if anti-stable eigenvalues should be computed via dense methods.
          mu
              |Parameter|.
              
      .. admonition:: Returns

          lev
              |VectorArray| of left eigenvectors.
          ew
              One-dimensional |NumPy array| of anti-stable eigenvalues sorted from smallest to
              largest.
          rev
              |VectorArray| of right eigenvectors.
              

   .. py:method:: moebius_substitution(self, M, sampling_time=0)


   .. py:method:: to_discrete(self, sampling_time, method='Tustin', w0=0)


   .. py:method:: to_continuous(self, method='Tustin', w0=0)



.. py:class:: SecondOrderModel(M, E, K, B, Cp, Cv=None, D=None, sampling_time=0, solver_options=None, error_estimator=None, visualizer=None, name=None)

   Bases: :py:obj:`pymor.models.interface.Model`

   Class for linear second order systems.

   This class describes input-output systems given by

   .. math::
       M(\mu) \ddot{x}(t, \mu)
       + E(\mu) \dot{x}(t, \mu)
       + K(\mu) x(t, \mu)
       & =
           B(\mu) u(t), \\
       y(t, \mu)
       & =
           C_p(\mu) x(t, \mu)
           + C_v(\mu) \dot{x}(t, \mu)
           + D(\mu) u(t),

   if continuous-time, or

   .. math::
       M(\mu) x(k + 2, \mu)
       + E(\mu) x(k + 1, \mu)
       + K(\mu) x(k, \mu)
       & =
           B(\mu) u(k), \\
       y(k, \mu)
       & =
           C_p(\mu) x(k, \mu)
           + C_v(\mu) x(k + 1, \mu)
           + D(\mu) u(k),

   if discrete-time, where :math:`M`, :math:`E`, :math:`K`, :math:`B`, :math:`C_p`, :math:`C_v`,
   and :math:`D` are linear operators.

   All methods related to the transfer function
   (e.g., frequency response calculation and Bode plots)
   are attached to the `transfer_function` attribute.

   .. admonition:: Parameters

       M
           The |Operator| M.
       E
           The |Operator| E.
       K
           The |Operator| K.
       B
           The |Operator| B.
       Cp
           The |Operator| Cp.
       Cv
           The |Operator| Cv or `None` (then Cv is assumed to be zero).
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       sampling_time
           `0` if the system is continuous-time, otherwise a positive number that denotes the
           sampling time (in seconds).
       solver_options
           The solver options to use to solve the Lyapunov equations.
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to M.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: M

      The |Operator| M.

   .. attribute:: E

      The |Operator| E.

   .. attribute:: K

      The |Operator| K.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: Cp

      The |Operator| Cp.

   .. attribute:: Cv

      The |Operator| Cv.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: transfer_function

      The transfer function.
      

   .. py:method:: __str__(self)

      Return str(self).


   .. py:method:: from_matrices(cls, M, E, K, B, Cp, Cv=None, D=None, sampling_time=0, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create a second order system from matrices.

      .. admonition:: Parameters

          M
              The |NumPy array| or |SciPy spmatrix| M.
          E
              The |NumPy array| or |SciPy spmatrix| E.
          K
              The |NumPy array| or |SciPy spmatrix| K.
          B
              The |NumPy array| or |SciPy spmatrix| B.
          Cp
              The |NumPy array| or |SciPy spmatrix| Cp.
          Cv
              The |NumPy array| or |SciPy spmatrix| Cv or `None` (then Cv is assumed to be zero).
          D
              The |NumPy array| or |SciPy spmatrix| D or `None` (then D is assumed to be zero).
          sampling_time
              `0` if the system is continuous-time, otherwise a positive number that denotes the
              sampling time (in seconds).
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          lti
              The SecondOrderModel with operators M, E, K, B, Cp, Cv, and D.
              

   .. py:method:: to_matrices(self)

      Return operators as matrices.

      .. admonition:: Returns

          M
              The |NumPy array| or |SciPy spmatrix| M.
          E
              The |NumPy array| or |SciPy spmatrix| E.
          K
              The |NumPy array| or |SciPy spmatrix| K.
          B
              The |NumPy array| or |SciPy spmatrix| B.
          Cp
              The |NumPy array| or |SciPy spmatrix| Cp.
          Cv
              The |NumPy array| or |SciPy spmatrix| Cv or `None` (if Cv is a `ZeroOperator`).
          D
              The |NumPy array| or |SciPy spmatrix| D or `None` (if D is a `ZeroOperator`).
              

   .. py:method:: from_files(cls, M_file, E_file, K_file, B_file, Cp_file, Cv_file=None, D_file=None, sampling_time=0, state_id='STATE', solver_options=None, error_estimator=None, visualizer=None, name=None)
      :classmethod:

      Create |LTIModel| from matrices stored in separate files.

      .. admonition:: Parameters

          M_file
              The name of the file (with extension) containing A.
          E_file
              The name of the file (with extension) containing E.
          K_file
              The name of the file (with extension) containing K.
          B_file
              The name of the file (with extension) containing B.
          Cp_file
              The name of the file (with extension) containing Cp.
          Cv_file
              `None` or the name of the file (with extension) containing Cv.
          D_file
              `None` or the name of the file (with extension) containing D.
          sampling_time
              `0` if the system is continuous-time, otherwise a positive number that denotes the
              sampling time (in seconds).
          state_id
              Id of the state space.
          solver_options
              The solver options to use to solve the Lyapunov equations.
          error_estimator
              An error estimator for the problem. This can be any object with an
              `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
              `estimate_error(U, mu)` method is added to the model which will call
              `error_estimator.estimate_error(U, mu, self)`.
          visualizer
              A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
              method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added
              to the model which forwards its arguments to the visualizer's `visualize` method.
          name
              Name of the system.
              
      .. admonition:: Returns

          some
              The |SecondOrderModel| with operators M, E, K, B, Cp, Cv, and D.
              

   .. py:method:: to_files(self, M_file, E_file, K_file, B_file, Cp_file, Cv_file=None, D_file=None)

      Write operators to files as matrices.

      .. admonition:: Parameters

          M_file
              The name of the file (with extension) containing M.
          E_file
              The name of the file (with extension) containing E.
          K_file
              The name of the file (with extension) containing K.
          B_file
              The name of the file (with extension) containing B.
          Cp_file
              The name of the file (with extension) containing Cp.
          Cv_file
              The name of the file (with extension) containing Cv or `None` if D is a `ZeroOperator`.
          D_file
              The name of the file (with extension) containing D or `None` if D is a `ZeroOperator`.
              

   .. py:method:: to_lti(self)

      Return a first order representation.

      The first order representation

      .. math::
          \begin{bmatrix}
              I & 0 \\
              0 & M
          \end{bmatrix}
          \frac{\mathrm{d}}{\mathrm{d}t}\!
          \begin{bmatrix}
              x(t) \\
              \dot{x}(t)
          \end{bmatrix}
          & =
          \begin{bmatrix}
              0 & I \\
              -K & -E
          \end{bmatrix}
          \begin{bmatrix}
              x(t) \\
              \dot{x}(t)
          \end{bmatrix}
          +
          \begin{bmatrix}
              0 \\
              B
          \end{bmatrix}
          u(t), \\
          y(t)
          & =
          \begin{bmatrix}
              C_p & C_v
          \end{bmatrix}
          \begin{bmatrix}
              x(t) \\
              \dot{x}(t)
          \end{bmatrix}
          + D u(t)

      is returned.

      .. admonition:: Returns

          lti
              |LTIModel| equivalent to the second-order model.
              

   .. py:method:: __add__(self, other)

      Add a |SecondOrderModel| or an |LTIModel|.


   .. py:method:: __radd__(self, other)

      Add to an |LTIModel|.


   .. py:method:: __sub__(self, other)

      Subtract a |SecondOrderModel| or an |LTIModel|.


   .. py:method:: __rsub__(self, other)

      Subtract from an |LTIModel|.


   .. py:method:: __neg__(self)

      Negate the |SecondOrderModel|.


   .. py:method:: __mul__(self, other)

      Postmultiply by a |SecondOrderModel| or an |LTIModel|.


   .. py:method:: __rmul__(self, other)

      Premultiply by an |LTIModel|.


   .. py:method:: poles(self, mu=None)

      Compute system poles.

      .. note::
          Assumes the systems is small enough to use a dense eigenvalue solver.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of system poles.
              

   .. py:method:: gramian(self, typ, mu=None)

      Compute a second-order Gramian.

      .. admonition:: Parameters

          typ
              The type of the Gramian:
              
              - `'pc_lrcf'`: low-rank Cholesky factor of the position controllability Gramian,
              - `'vc_lrcf'`: low-rank Cholesky factor of the velocity controllability Gramian,
              - `'po_lrcf'`: low-rank Cholesky factor of the position observability Gramian,
              - `'vo_lrcf'`: low-rank Cholesky factor of the velocity observability Gramian,
              - `'pc_dense'`: dense position controllability Gramian,
              - `'vc_dense'`: dense velocity controllability Gramian,
              - `'po_dense'`: dense position observability Gramian,
              - `'vo_dense'`: dense velocity observability Gramian.
              
              .. note::
                  For `'*_lrcf'` types, the method assumes the system is asymptotically stable.
                  For `'*_dense'` types, the method assumes that the underlying Lyapunov equation
                  has a unique solution, i.e. no pair of system poles adds to zero in the
                  continuous-time case and no pair of system poles multiplies to one in the
                  discrete-time case.
          mu
              |Parameter values|.
              
      .. admonition:: Returns

          If typ is `'pc_lrcf'`, `'vc_lrcf'`, `'po_lrcf'` or `'vo_lrcf'`, then the Gramian factor as a
          |VectorArray| from `self.M.source`.
          If typ is `'pc_dense'`, `'vc_dense'`, `'po_dense'` or `'vo_dense'`, then the Gramian as a
          |NumPy array|.
              

   .. py:method:: psv(self, mu=None)

      Position singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              

   .. py:method:: vsv(self, mu=None)

      Velocity singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              

   .. py:method:: pvsv(self, mu=None)

      Position-velocity singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              

   .. py:method:: vpsv(self, mu=None)

      Velocity-position singular values.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          One-dimensional |NumPy array| of singular values.
              

   .. py:method:: h2_norm(self, mu=None)

      Compute the H2-norm.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              H_2-norm.
              

   .. py:method:: hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False)

      Compute the H_infinity-norm.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
          return_fpeak
              Should the frequency at which the maximum is achieved should be returned.
          ab13dd_equilibrate
              Should `slycot.ab13dd` use equilibration.
              
      .. admonition:: Returns

          norm
              H_infinity-norm.
          fpeak
              Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
              

   .. py:method:: hankel_norm(self, mu=None)

      Compute the Hankel-norm.

      .. note::
          Assumes the system is asymptotically stable.

      .. admonition:: Parameters

          mu
              |Parameter values|.
              
      .. admonition:: Returns

          norm
              Hankel-norm.
              


.. py:class:: LinearDelayModel(A, Ad, tau, B, C, D=None, E=None, sampling_time=0, error_estimator=None, visualizer=None, name=None)

   Bases: :py:obj:`pymor.models.interface.Model`

   Class for linear delay systems.

   This class describes input-state-output systems given by

   .. math::
       E x'(t)
       & =
           A x(t)
           + \sum_{i = 1}^q{A_i x(t - \tau_i)}
           + B u(t), \\
       y(t)
       & =
           C x(t)
           + D u(t),

   if continuous-time, or

   .. math::
       E x(k + 1)
       & =
           A x(k)
           + \sum_{i = 1}^q{A_i x(k - \tau_i)}
           + B u(k), \\
       y(k)
       & =
           C x(k)
           + D u(k),

   if discrete-time, where :math:`E`, :math:`A`, :math:`A_i`, :math:`B`, :math:`C`, and :math:`D`
   are linear operators.

   All methods related to the transfer function
   (e.g., frequency response calculation and Bode plots)
   are attached to the `transfer_function` attribute.

   .. admonition:: Parameters

       A
           The |Operator| A.
       Ad
           The tuple of |Operators| A_i.
       tau
           The tuple of delay times (positive floats or ints).
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       sampling_time
           `0` if the system is continuous-time, otherwise a positive number that denotes the
           sampling time (in seconds).
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to A.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: q

      The number of delay terms.

   .. attribute:: tau

      The tuple of delay times.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: Ad

      The tuple of |Operators| A_i.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.

   .. attribute:: transfer_function

      The transfer function.
      

   .. py:method:: __str__(self)

      Return str(self).


   .. py:method:: __add__(self, other)

      Add an |LTIModel|, |SecondOrderModel| or |LinearDelayModel|.


   .. py:method:: __radd__(self, other)

      Add to an |LTIModel| or a |SecondOrderModel|.


   .. py:method:: __sub__(self, other)

      Subtract an |LTIModel|, |SecondOrderModel| or |LinearDelayModel|.


   .. py:method:: __rsub__(self, other)

      Subtract from an |LTIModel| or a |SecondOrderModel|.


   .. py:method:: __neg__(self)

      Negate the |LinearDelayModel|.


   .. py:method:: __mul__(self, other)

      Postmultiply an |LTIModel|, |SecondOrderModel| or |LinearDelayModel|.


   .. py:method:: __rmul__(self, other)

      Premultiply by an |LTIModel| or a |SecondOrderModel|.



.. py:class:: LinearStochasticModel(A, As, B, C, D=None, E=None, sampling_time=0, error_estimator=None, visualizer=None, name=None)

   Bases: :py:obj:`pymor.models.interface.Model`

   Class for linear stochastic systems.

   This class describes input-state-output systems given by

   .. math::
       E \mathrm{d}x(t)
       & =
           A x(t) \mathrm{d}t
           + \sum_{i = 1}^q{A_i x(t) \mathrm{d}\omega_i(t)}
           + B u(t) \mathrm{d}t, \\
       y(t)
       & =
           C x(t)
           + D u(t),

   if continuous-time, or

   .. math::
       E x(k + 1)
       & =
           A x(k)
           + \sum_{i = 1}^q{A_i x(k) \omega_i(k)}
           + B u(k), \\
       y(k)
       & =
           C x(k)
           + D u(t),

   if discrete-time, where :math:`E`, :math:`A`, :math:`A_i`, :math:`B`, :math:`C`, and :math:`D`
   are linear operators and :math:`\omega_i` are stochastic processes.

   .. admonition:: Parameters

       A
           The |Operator| A.
       As
           The tuple of |Operators| A_i.
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       sampling_time
           `0` if the system is continuous-time, otherwise a positive number that denotes the
           sampling time (in seconds).
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to A.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: q

      The number of stochastic processes.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: As

      The tuple of |Operators| A_i.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.
      

   .. py:method:: __str__(self)

      Return str(self).



.. py:class:: BilinearModel(A, N, B, C, D, E=None, sampling_time=0, error_estimator=None, visualizer=None, name=None)

   Bases: :py:obj:`pymor.models.interface.Model`

   Class for bilinear systems.

   This class describes input-output systems given by

   .. math::
       E x'(t)
       & =
           A x(t)
           + \sum_{i = 1}^m{N_i x(t) u_i(t)}
           + B u(t), \\
       y(t)
       & =
           C x(t)
           + D u(t),

   if continuous-time, or

   .. math::
       E x(k + 1)
       & =
           A x(k)
           + \sum_{i = 1}^m{N_i x(k) u_i(k)}
           + B u(k), \\
       y(k)
       & =
           C x(k)
           + D u(t),

   if discrete-time, where :math:`E`, :math:`A`, :math:`N_i`, :math:`B`, :math:`C`, and :math:`D`
   are linear operators and :math:`m` is the number of inputs.

   .. admonition:: Parameters

       A
           The |Operator| A.
       N
           The tuple of |Operators| N_i.
       B
           The |Operator| B.
       C
           The |Operator| C.
       D
           The |Operator| D or `None` (then D is assumed to be zero).
       E
           The |Operator| E or `None` (then E is assumed to be identity).
       sampling_time
           `0` if the system is continuous-time, otherwise a positive number that denotes the
           sampling time (in seconds).
       error_estimator
           An error estimator for the problem. This can be any object with an
           `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
           `estimate_error(U, mu)` method is added to the model which will call
           `error_estimator.estimate_error(U, mu, self)`.
       visualizer
           A visualizer for the problem. This can be any object with a `visualize(U, model, ...)`
           method. If `visualizer` is not `None`, a `visualize(U, *args, **kwargs)` method is added to
           the model which forwards its arguments to the visualizer's `visualize` method.
       name
           Name of the system.
           
   .. attribute:: order

      The order of the system (equal to A.source.dim).

   .. attribute:: dim_input

      The number of inputs.

   .. attribute:: dim_output

      The number of outputs.

   .. attribute:: A

      The |Operator| A.

   .. attribute:: N

      The tuple of |Operators| N_i.

   .. attribute:: B

      The |Operator| B.

   .. attribute:: C

      The |Operator| C.

   .. attribute:: D

      The |Operator| D.

   .. attribute:: E

      The |Operator| E.
      

   .. py:method:: __str__(self)

      Return str(self).



.. py:function:: _lti_to_poles_b_c(lti)

   Compute poles and residues.

   .. admonition:: Parameters

       lti
           |LTIModel| consisting of |Operators| that can be converted to |NumPy arrays|.
           The D operator is ignored.
           
   .. admonition:: Returns

       poles
           1D |NumPy array| of poles.
       b
           |NumPy array| of shape `(lti.order, lti.dim_input)`.
       c
           |NumPy array| of shape `(lti.order, lti.dim_output)`.
           

.. py:function:: _poles_b_c_to_lti(poles, b, c)

   Create an |LTIModel| from poles and residue rank-1 factors.

   Returns an |LTIModel| with real matrices such that its transfer
   function is

   .. math::
       \sum_{i = 1}^r \frac{c_i b_i^T}{s - \lambda_i}

   where :math:`\lambda_i, b_i, c_i` are the poles and residue rank-1
   factors.

   .. admonition:: Parameters

       poles
           Sequence of poles.
       b
           |NumPy array| of shape `(rom.order, rom.dim_input)`.
       c
           |NumPy array| of shape `(rom.order, rom.dim_output)`.
           
   .. admonition:: Returns

       |LTIModel|.
           

