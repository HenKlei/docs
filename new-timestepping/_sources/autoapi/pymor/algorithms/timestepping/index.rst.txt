:mod:`pymor.algorithms.timestepping`
====================================

.. py:module:: pymor.algorithms.timestepping

.. autoapi-nested-parse::

   Generic time-stepping algorithms for the solution of instationary problems.

   The algorithms are generic in the sense that each algorithms operates exclusively
   on |Operators| and |VectorArrays|. In particular, the algorithms
   can also be used to turn an arbitrary stationary |Model| provided
   by an external library into an instationary |Model|.

   Currently, implementations of :func:`explicit_euler` and :func:`implicit_euler`
   time-stepping are provided, based on the :class:`ExplicitEulerTimeStepper` and
   :class:`ImplicitEulerTimeStepper` classes. These derive from :class:`TimeStepper`,
   which defines a common interface that has to be fulfilled by the time-steppers used
   by |InstationaryModel|.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pymor.algorithms.timestepping.TimeStepper
   pymor.algorithms.timestepping.TimeStepperIterator
   pymor.algorithms.timestepping.SingleStepTimeStepperIterator
   pymor.algorithms.timestepping.ImplicitEulerIterator
   pymor.algorithms.timestepping.ImplicitEulerTimeStepper
   pymor.algorithms.timestepping.ExplicitEulerIterator
   pymor.algorithms.timestepping.ExplicitEulerTimeStepper
   pymor.algorithms.timestepping.ExplicitRungeKuttaIterator
   pymor.algorithms.timestepping.ExplicitRungeKuttaTimeStepper



Functions
~~~~~~~~~

.. autoapisummary::
  :nosignatures:

   pymor.algorithms.timestepping._depends_on_time
   pymor.algorithms.timestepping.implicit_euler
   pymor.algorithms.timestepping.explicit_euler



.. py:class:: TimeStepper(num_values=None, interpolation='P1')

   Bases: :py:obj:`pymor.core.base.ImmutableObject`

   Interface for time-stepping algorithms.

   Algorithms implementing this interface solve time-dependent initial value problems
   of the form ::

       M * d_t u + A(u, mu, t) = F(mu, t),
                    u(mu, t_0) = u_0(mu).

   Time-steppers used by |InstationaryModel| have to fulfill this interface. Time evolution can be
   performed by calling :meth:`solve`.

   Note that the actual work is done in an iterator derived from :class:`TimeStepperIterator`.

   .. admonition:: Parameters

       num_values
           The number of returned vectors of the solution trajectory. If `None`, each intermediate
           vector that is calculated is returned. Else an interpolation of the calculated vectors on an
           equidistant temporal grid is returned, using an appropriate interpolation of the respective
           time stepper.
       interpolation
           Type of temporal interpolation to be used. Currently implemented are: piecewise constant
           (P0) and piecewise linear (P1).
           
   .. py:attribute:: IteratorType
      

      

   .. py:attribute:: available_interpolations
      :annotation: = ['P0', 'P1']

      

   .. py:method:: solve(self, t0, t1, U0, A, F=None, M=None, mu=None, return_iter=False, return_times=False)

      Apply time-stepper to the equation ::

          M * d_t u + A(u, mu, t) = F(mu, t),
                       u(mu, t_0) = u_0(mu).

      .. admonition:: Parameters

          t0
              The time at which to begin time-stepping.
          t1
              The time until which to perform time-stepping.
          U0
              The solution vector at `t0`.
          A
              The |Operator| A.
          F
              The right-hand side F (either |VectorArray| of length 1 or |Operator| with
              `source.dim == 1`). If `None`, zero right-hand side is assumed.
          M
              The |Operator| M. If `None`, the identity operator is assumed.
          mu
              |Parameter values| for which `operator` and `rhs` are evaluated. The current
              time is added to `mu` with key `t`.
          return_iter
              Determines the return data, see below.
          return_times
              Determines the return data, see below.
              
      .. admonition:: Returns

          U
              If `return_iter` is `False` and `return_times` is `False` (the default), where `U` is a
              |VectorArray| containing the solution trajectory.
          (U, t)
              If `return_iter` is `False` and `return_times` is `True`, where `t` is the list of time
              points corresponding to the solution vectors in `U`.
          iterator
              If `return_iter` is `True`, an iterator yielding either `U_n` (if `return_times` is
              `False`) or `(U_n, t_n)` in each step.
              


.. py:class:: TimeStepperIterator(stepper, t0, t1, U0, A, F, M, mu, return_iter, return_times)

   Bases: :py:obj:`pymor.core.base.BasicObject`

   Base class to derive time-stepper iterators from.

   See :meth:`TimeStepper.solve` for a documentation of the init parameters except `stepper`.

   .. note::
       Derived classes usually only have to implement :meth:`_step`, and optionally
       :meth:`_interpolate` if none of the provided interpolations are suitable. Using the
       interpolation from this base class requires the implementor to store certain data in each
       step (see :meth:`_interpolate`).

   .. admonition:: Parameters

       stepper
           The associated :class:`TimeStepper`.
           
   .. py:method:: _step(self)
      :abstractmethod:

      Called in :meth:`_interpolated_step` to compute the next step of the time evolution.

      The iterator is assumed to be in the n-th time-step, `self.t == t_n`, the current state of
      the solution is often available as `self.U_n` (depending on the interpolation and the choice
      of the implementor).

      .. admonition:: Returns

          U_np1
              A |VectorArray| of length 1 containing U(t_{n + 1}).
          t_np1
              The next time instance t_{n + 1} = t_n + dt, where dt has to be determined by the
              implementor.
              

   .. py:method:: _interpolate(self, t)

      Called in :meth:`_interpolated_step` to compute an interpolated value of the solution.

      If not overridden in derived classes, requires the following data to be present after a call
      to :meth:`_step`:
      - P0: self.t_n, self.t_np1, self.U_n
      - P1: self.t_n, self.t_np1, self.U_n, self.U_np1

      .. admonition:: Parameters

          t
              The interpolation point within the latest computed step interval.
              
      .. admonition:: Returns

          U
              A |VectorArray| of length 1 containing U(t).
              

   .. py:method:: _interpolated_step(self)

      Returns `(U_next, t_next)` (if `return_times == True`, otherwise `U_next`), behavior depends
      on `num_values`: If `num_values` is provided, performs as many actual steps
      (by calling :meth:`_step`) as required to obtain an interpolation of the solution, U(t_next)
      at the next required interpolation point t_next >= t_n, and returns (U(t_next), t_next). If
      `num_values` is not provided, performs a single step (by calling :meth:`_step`) starting
      from t_n, to compute (U(t_{n + 1}), t_{n + 1}).


   .. py:method:: __iter__(self)


   .. py:method:: __next__(self)



.. py:class:: SingleStepTimeStepperIterator(stepper, t0, t1, U0, A, F, M, mu, return_iter, return_times)

   Bases: :py:obj:`TimeStepperIterator`

   Base class for iterators of single-step methods.

   See :meth:`TimeStepperIterator` for a documentation of the init parameters.

   Note: derived classes only have to implement :meth:`_step_function`, and optionally
   :meth:`_interpolate`

   .. py:method:: _step_function(self, U_n, t_n)
      :abstractmethod:


   .. py:method:: _step(self)

      Called in :meth:`_interpolated_step` to compute the next step of the time evolution.

      The iterator is assumed to be in the n-th time-step, `self.t == t_n`, the current state of
      the solution is often available as `self.U_n` (depending on the interpolation and the choice
      of the implementor).

      .. admonition:: Returns

          U_np1
              A |VectorArray| of length 1 containing U(t_{n + 1}).
          t_np1
              The next time instance t_{n + 1} = t_n + dt, where dt has to be determined by the
              implementor.
              


.. py:class:: ImplicitEulerIterator(stepper, t0, t1, U0, A, F, M, mu, return_iter, return_times)

   Bases: :py:obj:`SingleStepTimeStepperIterator`

   Base class for iterators of single-step methods.

   See :meth:`TimeStepperIterator` for a documentation of the init parameters.

   Note: derived classes only have to implement :meth:`_step_function`, and optionally
   :meth:`_interpolate`

   .. py:method:: _step_function(self, U_n, t_n)



.. py:class:: ImplicitEulerTimeStepper(nt, num_values=None, solver_options='operator', interpolation='P1')

   Bases: :py:obj:`TimeStepper`

   Implicit Euler :class:`TimeStepper`.

   Solves equations of the form ::

       M * d_t u + A(u, mu, t) = F(mu, t),
                    u(mu, t_0) = u_0(mu),

   by an implicit Euler time integration, implemented in :class:`ImplicitEulerIterator`.

   .. admonition:: Parameters

       nt
           The number of time-steps the time-stepper will perform.
       num_values
           The number of returned vectors of the solution trajectory. If `None`, each intermediate
           vector that is calculated is returned. Else an interpolation of the calculated vectors on an
           equidistant temporal grid is returned, using an appropriate interpolation of the respective
           time stepper.
       solver_options
           The |solver_options| used to invert `M + dt*A`. The special values `'mass'` and `'operator'`
           are recognized, in which case the solver_options of `M` (resp. `A`) are used.
       interpolation
           Type of temporal interpolation to be used. Currently implemented are: piecewise constant
           (P0) and piecewise linear (P1).
           
   .. py:attribute:: IteratorType
      

      


.. py:class:: ExplicitEulerIterator(stepper, t0, t1, U0, A, F, M, mu, return_iter, return_times)

   Bases: :py:obj:`SingleStepTimeStepperIterator`

   Base class for iterators of single-step methods.

   See :meth:`TimeStepperIterator` for a documentation of the init parameters.

   Note: derived classes only have to implement :meth:`_step_function`, and optionally
   :meth:`_interpolate`

   .. py:method:: _step_function(self, U_n, t_n)



.. py:class:: ExplicitEulerTimeStepper(nt, num_values=None, interpolation='P1')

   Bases: :py:obj:`TimeStepper`

   Explicit Euler :class:`TimeStepper`.

   Solves equations of the form ::

       M * d_t u + A(u, mu, t) = F(mu, t),
                    u(mu, t_0) = u_0(mu),

   by an explicit Euler time integration, implemented in :class:`ExplicitEulerIterator`.

   .. admonition:: Parameters

       nt
           The number of time-steps the time-stepper will perform.
       num_values
           The number of returned vectors of the solution trajectory. If `None`, each intermediate
           vector that is calculated is returned. Else an interpolation of the calculated vectors on an
           equidistant temporal grid is returned, using an appropriate interpolation of the respective
           time stepper.
       interpolation
           Type of temporal interpolation to be used. Currently implemented are: piecewise constant
           (P0) and piecewise linear (P1).
           
   .. py:attribute:: IteratorType
      

      


.. py:class:: ExplicitRungeKuttaIterator(stepper, t0, t1, U0, A, F, M, mu, return_iter, return_times)

   Bases: :py:obj:`SingleStepTimeStepperIterator`

   Base class for iterators of single-step methods.

   See :meth:`TimeStepperIterator` for a documentation of the init parameters.

   Note: derived classes only have to implement :meth:`_step_function`, and optionally
   :meth:`_interpolate`

   .. py:method:: _step_function(self, U_n, t_n)



.. py:class:: ExplicitRungeKuttaTimeStepper(method, nt, num_values=None, interpolation='P1')

   Bases: :py:obj:`TimeStepper`

   Explicit Runge-Kutta :class:`TimeStepper`.

   Solves equations of the form ::

       M * d_t u + A(u, mu, t) = F(mu, t).
                    u(mu, t_0) = u_0(mu),

   by a Runge-Kutta method, implemented in :class:`ExplicitRungeKuttaIterator`.

   .. admonition:: Parameters

       method
           Either a string identifying the method or a tuple (c, A, b) of butcher tableaus.
       nt
           The number of time-steps the time-stepper will perform.
       num_values
           The number of returned vectors of the solution trajectory. If `None`, each intermediate
           vector that is calculated is returned. Else an interpolation of the calculated vectors on an
           equidistant temporal grid is returned, using an appropriate interpolation of the respective
           time stepper.
           
   .. py:attribute:: IteratorType
      

      

   .. py:attribute:: available_RK_methods
      

      


.. py:function:: _depends_on_time(obj, mu)


.. py:function:: implicit_euler(A, F, M, U0, t0, t1, nt, mu=None, num_values=None, solver_options='operator')


.. py:function:: explicit_euler(A, F, U0, t0, t1, nt, mu=None, num_values=None)


